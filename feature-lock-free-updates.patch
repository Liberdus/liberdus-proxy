diff --git a/src/archivers.rs b/src/archivers.rs
index fdca77a..d570756 100644
--- a/src/archivers.rs
+++ b/src/archivers.rs
@@ -6,14 +6,15 @@
 //! allowing seamless integration in a highly concurrent environment.
 use crate::config;
 use crate::crypto::ShardusCrypto;
+use crate::shared_data::SharedData;
 use std::fs;
 use std::sync::Arc;
-use tokio::{io::AsyncWriteExt, sync::RwLock};
+use tokio::io::AsyncWriteExt;

 pub struct ArchiverUtil {
     config: config::Config,
-    seed_list: Arc<RwLock<Vec<Archiver>>>,
-    active_archivers: Arc<RwLock<Vec<Archiver>>>,
+    seed_list: Arc<SharedData<Vec<Archiver>>>,
+    active_archivers: Arc<SharedData<Vec<Archiver>>>,
     crypto: Arc<ShardusCrypto>,
 }

@@ -56,8 +57,8 @@ impl ArchiverUtil {

         ArchiverUtil {
             config,
-            seed_list: Arc::new(RwLock::new(seed)),
-            active_archivers: Arc::new(RwLock::new(Vec::new())),
+            seed_list: Arc::new(SharedData::new(seed)),
+            active_archivers: Arc::new(SharedData::new(Vec::new())),
             crypto: sc,
         }
     }
@@ -83,7 +84,7 @@ impl ArchiverUtil {
             Err(_) => Vec::new(),
         };

-        cache.extend(self.seed_list.read().await.clone());
+        cache.extend(self.seed_list.get().as_ref().clone());
         cache.dedup_by(|a, b| a.publicKey == b.publicKey);

         let (tx, mut rx) =
@@ -154,11 +155,7 @@ impl ArchiverUtil {

         let dump = tmp.clone();

-        {
-            let mut guard = long_lived_self.active_archivers.write().await;
-            *guard = tmp;
-            drop(guard);
-        }
+        long_lived_self.active_archivers.update(tmp);

         tokio::spawn(async move {
             let mut file = tokio::fs::File::create("known_archiver_cache.json")
@@ -170,7 +167,7 @@ impl ArchiverUtil {
     }

     /// Returns the reference counted clone of active archivers list.
-    pub fn get_active_archivers(&self) -> Arc<RwLock<Vec<Archiver>>> {
+    pub fn get_active_archivers(&self) -> Arc<SharedData<Vec<Archiver>>> {
         self.active_archivers.clone()
     }

@@ -208,7 +205,7 @@ mod tests {
     use std::time::Duration;
     use tokio::io::{AsyncReadExt, AsyncWriteExt};
     use tokio::net::TcpListener;
-    use tokio::sync::Mutex;
+    use tokio::sync::{Mutex, RwLock};
     use tokio::time::timeout;

     static CACHE_LOCK: Mutex<()> = Mutex::const_new(());
@@ -363,7 +360,7 @@ Connection: close
         server.await.unwrap();

         let active = util.get_active_archivers();
-        let guard = active.read().await;
+        let guard = active.get();
         assert_eq!(guard.len(), 1);
         assert_eq!(guard[0].publicKey, "returned_pk");
         assert_eq!(guard[0].ip, "10.0.0.1");
@@ -414,7 +411,7 @@ Connection: close
         server.await.unwrap();

         let active = util.get_active_archivers();
-        let guard = active.read().await;
+        let guard = active.get();
         assert!(guard.is_empty());
         assert!(!std::path::Path::new("known_archiver_cache.json").exists());
     }
diff --git a/src/http.rs b/src/http.rs
index 7ac25e8..5daeb0c 100644
--- a/src/http.rs
+++ b/src/http.rs
@@ -509,14 +509,14 @@ pub fn strip_route_root(header_bytes: &[u8]) -> Vec<u8> {
 #[cfg(test)]
 mod tests {
     use super::*;
-    use crate::ws::SocketIdents;
+    use crate::{shared_data::SharedData, ws::SocketIdents};
     use tokio::io::{AsyncReadExt, AsyncWrite, AsyncWriteExt};
     use tokio::sync::RwLock;

     fn test_liberdus() -> Arc<liberdus::Liberdus> {
         let cfg = config::Config::load().expect("config should load");
         let sc = Arc::new(crate::crypto::ShardusCrypto::new(&cfg.crypto_seed));
-        let archivers = Arc::new(tokio::sync::RwLock::new(Vec::<crate::archivers::Archiver>::new()));
+        let archivers = Arc::new(SharedData::new(Vec::<crate::archivers::Archiver>::new()));
         Arc::new(liberdus::Liberdus::new(sc, archivers, cfg))
     }

diff --git a/src/lib.rs b/src/lib.rs
index 0f06030..58154ad 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -7,6 +7,7 @@ pub struct Stats {
 }

 pub mod archivers;
+pub mod shared_data;
 pub mod collector;
 pub mod config;
 pub mod crypto;
diff --git a/src/liberdus.rs b/src/liberdus.rs
index e100776..0047973 100644
--- a/src/liberdus.rs
+++ b/src/liberdus.rs
@@ -1,6 +1,6 @@
 //! This module contains the node management logic require for load balancing with consensor nodes
 use crate::crypto;
-use crate::{archivers, collector, config, http};
+use crate::{archivers, collector, config, http, shared_data::SharedData};
 use rand::prelude::*;
 use serde::{self, Deserialize, Serialize};
 use std::{
@@ -42,9 +42,9 @@ pub struct Signature {
 }

 pub struct Liberdus {
-    pub active_nodelist: Arc<RwLock<Vec<Consensor>>>,
+    pub active_nodelist: Arc<SharedData<Vec<Consensor>>>,
     trip_ms: Arc<RwLock<HashMap<String, u128>>>,
-    archivers: Arc<RwLock<Vec<archivers::Archiver>>>,
+    archivers: Arc<SharedData<Vec<archivers::Archiver>>>,
     round_robin_index: Arc<AtomicUsize>,
     list_prepared: Arc<AtomicBool>,
     crypto: Arc<crypto::ShardusCrypto>,
@@ -55,14 +55,14 @@ pub struct Liberdus {
 impl Liberdus {
     pub fn new(
         sc: Arc<crypto::ShardusCrypto>,
-        archivers: Arc<RwLock<Vec<archivers::Archiver>>>,
+        archivers: Arc<SharedData<Vec<archivers::Archiver>>>,
         config: config::Config,
     ) -> Self {
         Liberdus {
             config: Arc::new(config),
             round_robin_index: Arc::new(AtomicUsize::new(0)),
             trip_ms: Arc::new(RwLock::new(HashMap::new())),
-            active_nodelist: Arc::new(RwLock::new(Vec::new())),
+            active_nodelist: Arc::new(SharedData::new(Vec::new())),
             list_prepared: Arc::new(AtomicBool::new(false)),
             archivers,
             crypto: sc,
@@ -72,7 +72,7 @@ impl Liberdus {

     /// trigger a full nodelist update from one of the archivers
     pub async fn update_active_nodelist(&self) {
-        let archivers = self.archivers.read().await;
+        let archivers = self.archivers.get();

         for archiver in archivers.iter() {
             let url = format!(
@@ -142,10 +142,7 @@ impl Liberdus {
                                  nodelist.len(), self.config.node_filtering.min_nodes_for_filtering);
                     }

-                    {
-                        let mut guard = self.active_nodelist.write().await;
-                        *guard = nodelist;
-                    }
+                    self.active_nodelist.update(nodelist);

                     self.round_robin_index
                         .store(0, std::sync::atomic::Ordering::Relaxed);
@@ -287,10 +284,7 @@ impl Liberdus {
             return;
         }

-        let nodes = {
-            let guard = self.active_nodelist.read().await;
-            guard.clone()
-        };
+        let nodes = self.active_nodelist.get();

         let trip_ms = {
             let guard = self.trip_ms.read().await;
@@ -298,7 +292,7 @@ impl Liberdus {
         };

         let max_timeout = self.config.max_http_timeout_ms.try_into().unwrap_or(4000); // 3 seconds
-        let mut sorted_nodes = nodes;
+        let mut sorted_nodes = nodes.as_ref().clone();

         sorted_nodes.sort_by(|a, b| {
             let a_time = trip_ms.get(&a.id).unwrap_or(&max_timeout);
@@ -316,10 +310,7 @@ impl Liberdus {
             cumulative_bias.push(total_bias);
         }

-        {
-            let mut guard = self.active_nodelist.write().await;
-            *guard = sorted_nodes;
-        }
+        self.active_nodelist.update(sorted_nodes);

         {
             let mut guard = self.load_distribution_commulative_bias.write().await;
@@ -342,7 +333,7 @@ impl Liberdus {
             return None;
         }

-        let nodes = self.active_nodelist.read().await.clone();
+        let nodes = self.active_nodelist.get();
         let cumulative_weights = self.load_distribution_commulative_bias.read().await.clone();

         if nodes.is_empty() || cumulative_weights.is_empty() {
@@ -382,7 +373,7 @@ impl Liberdus {
     /// node selection. Subsequent call will be redirected towards the node based on that bias and round robin
     /// is dismissed.
     pub async fn get_next_appropriate_consensor(&self) -> Option<(usize, Consensor)> {
-        if self.active_nodelist.read().await.is_empty() {
+        if self.active_nodelist.get().is_empty() {
             return None;
         }
         match self
@@ -394,7 +385,7 @@ impl Liberdus {
                 .await
                 .clone()
                 .len()
-                == self.active_nodelist.read().await.len())
+                == self.active_nodelist.get().len())
         {
             true => self.get_random_consensor_biased().await,
             false => {
@@ -402,7 +393,7 @@ impl Liberdus {
                     .round_robin_index
                     .fetch_add(1, std::sync::atomic::Ordering::Relaxed);

-                let nodes = self.active_nodelist.read().await;
+                let nodes = self.active_nodelist.get();
                 if index >= nodes.len() {
                     // dropping the `nodes` is really important here
                     // prepare_list() will acquire write lock
@@ -571,6 +562,8 @@ mod tests {
     use tokio::net::TcpListener;
     use tokio::sync::RwLock;

+use crate::shared_data::SharedData;
+
     #[tokio::test(flavor = "multi_thread", worker_threads = 1)]
     async fn test_weighted_random() {
         let mut nodes: Vec<Consensor> = Vec::new();
@@ -583,7 +576,7 @@ mod tests {
             publicKey: "0x0".to_string(),
         };

-        let archivers = Arc::new(RwLock::new(vec![_mock_archiver]));
+        let archivers = Arc::new(SharedData::new(vec![_mock_archiver]));
         let liberdus = Liberdus::new(
             Arc::new(crypto::ShardusCrypto::new(
                 "69fa4195670576c0160d660c3be36556ff8d504725be8a59b5a96509e0c994bc",
@@ -603,7 +596,7 @@ mod tests {
             nodes.push(node);
         }

-        liberdus.active_nodelist.write().await.extend(nodes);
+        liberdus.active_nodelist.update(nodes);

         liberdus
             .round_robin_index
@@ -689,7 +682,7 @@ mod tests {
         ));
         Liberdus::new(
             crypto,
-            Arc::new(RwLock::new(Vec::new())),
+            Arc::new(SharedData::new(Vec::new())),
             sample_config(),
         )
     }
@@ -705,11 +698,10 @@ mod tests {
     #[tokio::test]
     async fn prepare_list_sorts_nodes_by_rtt() {
         let liberdus = sample_liberdus();
-        {
-            let mut nodes = liberdus.active_nodelist.write().await;
-            nodes.push(Consensor {
-                id: "slow".into(),
-                ip: "127.0.0.1".into(),
+        let mut nodes = liberdus.active_nodelist.get().as_ref().clone();
+        nodes.push(Consensor {
+            id: "slow".into(),
+            ip: "127.0.0.1".into(),
                 port: 80,
                 publicKey: "pk1".into(),
                 rng_bias: None,
@@ -721,7 +713,7 @@ mod tests {
                 publicKey: "pk2".into(),
                 rng_bias: None,
             });
-        }
+        liberdus.active_nodelist.update(nodes);

         {
             let mut trips = liberdus.trip_ms.write().await;
@@ -731,7 +723,7 @@ mod tests {

         liberdus.prepare_list().await;

-        let ordered = liberdus.active_nodelist.read().await.clone();
+        let ordered = liberdus.active_nodelist.get();
         assert_eq!(ordered[0].id, "fast");
         assert!(ordered[0].rng_bias.unwrap() > ordered[1].rng_bias.unwrap());

@@ -830,7 +822,7 @@ mod tests {
         ))
         .await;

-        let archivers = Arc::new(RwLock::new(vec![
+        let archivers = Arc::new(SharedData::new(vec![
             archivers::Archiver {
                 ip: "127.0.0.1".into(),
                 port: bad_port,
@@ -857,7 +849,7 @@ mod tests {
         bad_server.abort();
         good_server.abort();

-        let list = liberdus.active_nodelist.read().await.clone();
+        let list = liberdus.active_nodelist.get();
         assert_eq!(list.len(), 2);
         assert!(list.iter().all(|n| n.ip == "192.0.2.1"));
         assert!(list.iter().all(|n| n.id == "node1" || n.id == "node2"));
@@ -911,7 +903,7 @@ mod tests {

         let liberdus = Liberdus::new(
             Arc::new(crypto::ShardusCrypto::new(&cfg.crypto_seed)),
-            Arc::new(RwLock::new(Vec::new())),
+            Arc::new(SharedData::new(Vec::new())),
             cfg.clone(),
         );

@@ -941,20 +933,19 @@ mod tests {

         let liberdus = Liberdus::new(
             Arc::new(crypto::ShardusCrypto::new(&cfg.crypto_seed)),
-            Arc::new(RwLock::new(Vec::new())),
+            Arc::new(SharedData::new(Vec::new())),
             cfg,
         );

-        {
-            let mut nodes = liberdus.active_nodelist.write().await;
-            nodes.push(Consensor {
-                id: "n1".into(),
-                ip: "127.0.0.1".into(),
+        let mut nodes = liberdus.active_nodelist.get().as_ref().clone();
+        nodes.push(Consensor {
+            id: "n1".into(),
+            ip: "127.0.0.1".into(),
                 port: cons_port,
                 publicKey: String::new(),
                 rng_bias: Some(1.0),
             });
-        }
+        liberdus.active_nodelist.update(nodes);
         liberdus
             .load_distribution_commulative_bias
             .write()
@@ -988,16 +979,15 @@ mod tests {
         .await;

         let liberdus = sample_liberdus();
-        {
-            let mut nodes = liberdus.active_nodelist.write().await;
-            nodes.push(Consensor {
-                id: "fast".into(),
-                ip: "127.0.0.1".into(),
+        let mut nodes = liberdus.active_nodelist.get().as_ref().clone();
+        nodes.push(Consensor {
+            id: "fast".into(),
+            ip: "127.0.0.1".into(),
                 port,
                 publicKey: String::new(),
                 rng_bias: Some(1.0),
             });
-        }
+        liberdus.active_nodelist.update(nodes);
         liberdus
             .load_distribution_commulative_bias
             .write()
@@ -1033,16 +1023,15 @@ mod tests {
         cfg.max_http_timeout_ms = 100;

         let liberdus = sample_liberdus();
-        {
-            let mut nodes = liberdus.active_nodelist.write().await;
-            nodes.push(Consensor {
-                id: "fast".into(),
-                ip: "127.0.0.1".into(),
+        let mut nodes = liberdus.active_nodelist.get().as_ref().clone();
+        nodes.push(Consensor {
+            id: "fast".into(),
+            ip: "127.0.0.1".into(),
                 port: 9_999,
                 publicKey: String::new(),
                 rng_bias: Some(1.0),
             });
-        }
+        liberdus.active_nodelist.update(nodes);
         liberdus
             .load_distribution_commulative_bias
             .write()
@@ -1073,11 +1062,10 @@ mod tests {
     #[tokio::test]
     async fn get_next_round_robins_then_bias() {
         let liberdus = sample_liberdus();
-        {
-            let mut nodes = liberdus.active_nodelist.write().await;
-            nodes.push(Consensor {
-                id: "one".into(),
-                ip: "127.0.0.1".into(),
+        let mut nodes = liberdus.active_nodelist.get().as_ref().clone();
+        nodes.push(Consensor {
+            id: "one".into(),
+            ip: "127.0.0.1".into(),
                 port: 80,
                 publicKey: "pk1".into(),
                 rng_bias: None,
@@ -1089,7 +1077,7 @@ mod tests {
                 publicKey: "pk2".into(),
                 rng_bias: None,
             });
-        }
+        liberdus.active_nodelist.update(nodes);

         {
             let mut trips = liberdus.trip_ms.write().await;
diff --git a/src/main.rs b/src/main.rs
index 6272d99..21ea3ce 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -36,30 +36,18 @@
 //! ```bash
 //! cargo run
 //! ```
-mod archivers;
-mod collector;
-mod notifier;
-mod config;
-mod crypto;
-mod http;
-mod liberdus;
-mod rpc;
-mod shardus_monitor;
-mod subscription;
-mod tls;
-mod ws;
-
 use std::collections::HashMap;
 use std::fs;
 use std::sync::atomic::AtomicUsize;
 use std::sync::Arc;
 use tokio::sync::RwLock;
 use tokio_rustls::TlsAcceptor;
-use liberdus_proxy::Stats;
+
+use liberdus_proxy::*;

 #[tokio::main]
 async fn main() -> Result<(), Box<dyn std::error::Error>> {
-    let _configs = config::Config::load().unwrap_or_else(|err| {
+    let _configs = Config::load().unwrap_or_else(|err| {
         eprintln!("Failed to load config: {}", err);
         std::process::exit(1);
     });
@@ -127,7 +115,7 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {

     println!("Waiting for active nodelist...");
     loop {
-        if lbd.active_nodelist.read().await.len() > 0 {
+        if lbd.active_nodelist.get().len() > 0 {
             break;
         }
     }
diff --git a/src/shared_data.rs b/src/shared_data.rs
new file mode 100644
index 0000000..32efe6f
--- /dev/null
+++ b/src/shared_data.rs
@@ -0,0 +1,30 @@
+
+use std::sync::Arc;
+use tokio::sync::watch;
+
+pub struct SharedData<T> {
+    tx: watch::Sender<Arc<T>>,
+    rx: watch::Receiver<Arc<T>>,
+}
+
+impl<T> SharedData<T>
+where
+    T: Clone,
+{
+    pub fn new(initial_value: T) -> Self {
+        let (tx, rx) = watch::channel(Arc::new(initial_value));
+        Self { tx, rx }
+    }
+
+    pub fn update(&self, new_value: T) {
+        self.tx.send(Arc::new(new_value)).ok();
+    }
+
+    pub fn get(&self) -> Arc<T> {
+        self.rx.borrow().clone()
+    }
+
+    pub fn get_receiver(&self) -> watch::Receiver<Arc<T>> {
+        self.rx.clone()
+    }
+}
diff --git a/src/subscription.rs b/src/subscription.rs
index 3db7435..e0823ed 100644
--- a/src/subscription.rs
+++ b/src/subscription.rs
@@ -384,7 +384,7 @@ pub mod rpc_handler {
 #[cfg(test)]
 pub(crate) mod tests {
     use super::*;
-    use crate::crypto::ShardusCrypto;
+    use crate::{crypto::ShardusCrypto, shared_data::SharedData};

     fn sample_config() -> crate::config::Config {
         crate::config::Config {
@@ -436,7 +436,7 @@ pub(crate) mod tests {
         ));
         let liberdus = Arc::new(crate::liberdus::Liberdus::new(
             crypto,
-            Arc::new(tokio::sync::RwLock::new(Vec::new())),
+            Arc::new(SharedData::new(Vec::new())),
             sample_config(),
         ));
         Manager::new(Arc::new(tokio::sync::RwLock::new(HashMap::new())), liberdus)
diff --git a/src/ws.rs b/src/ws.rs
index ca7d77d..dcf7dfa 100644
--- a/src/ws.rs
+++ b/src/ws.rs
@@ -332,14 +332,14 @@ where
 #[cfg(test)]
 mod tests {
     use super::*;
-    use crate::{archivers, config, crypto};
+    use crate::{archivers, config, crypto, shared_data::SharedData};
     use tokio::net::TcpListener;
     use tokio_tungstenite::tungstenite::protocol::Message;

     fn test_liberdus() -> Arc<liberdus::Liberdus> {
         let cfg = config::Config::load().expect("config should load");
         let sc = Arc::new(crypto::ShardusCrypto::new(&cfg.crypto_seed));
-        let archivers = Arc::new(tokio::sync::RwLock::new(Vec::<archivers::Archiver>::new()));
+        let archivers = Arc::new(SharedData::new(Vec::<archivers::Archiver>::new()));
         Arc::new(liberdus::Liberdus::new(sc, archivers, cfg))
     }
